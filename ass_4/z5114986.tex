\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{chngcntr}
%\usepackage{tikz}

\lhead{Evan Kohilas - z5114986}
\rhead{COMP3821 - Assignment 4}
\pagestyle{fancy}
\title{A17S1N4}
\counterwithin*{equation}{section}
\usepackage{parskip}

%\begin{verbatim}
%code goes here
%\end{verbatim}

\begin{document}

\begin{center}
    \begin{LARGE}
        COMP3121\\
        Assignment 4\\
        A17S1N3\\
        \hrulefill\\
        Evangelos Kohilas\\
        z5114986\\
        \hrulefill
    \end{LARGE}

    \begin{large}
        By submitting this document you are confirming that all the answers are your work and are not take from any other sources unless clearly mentioned.
    \end{large}

\end{center}

\section*{Question 1}
To create the longest subsequence of elephants, we first sort the elephants in decreasing order of IQs$^{12}$.

Then, we find the longest increasing subsequence of weight from our collection of sorted elephants.

Let $S$ be our sorted collection, with $S[i]$ denoting the $i^{th}$ elephant in the sequence.\\
Let $W(i)$ be the given weight of elephant $i$.

Then, for each elephant $i$ in the collection, we let our subproblem be finding a subsequence of maximum length such that $W(i)$ is increasing and the subsequence ends with elephant $i$.

We do this process recursively, assuming we have solved all the subproblems for some $j < i$, and we look for all elephants $m$ such that $W(m) \leq W(i)$ and $S[m] \leq  S[i]$, picking elephant $m$ which produced the longest increasing subsequence ending with $m$, and extending it to our subproblem to obtain the longest increasing subsequence ending with elephant $i$

Our solution is optimal as truncating the solution $i$ will produce the optimal solution of the subproblem $m$.

$^1$ Sorting by the weight will also achieve the same result provided the method is inversed.\\
$^2$ If two elephants have the same value, we then sort those elephants by the respective inverse of the other value.

%\pagebreak
\section*{Question 2}
Let $A$ be the sequence of wooden peices that will be cut from dividing the wooden stick respective to its marks, with $A[i]$ denoting the size of the $i^{th}$ peice in the sequence.\\
Let $n$ be the total number of respective peices.

Let the subproblems to be considered as $c(i, j)$ be the minimum of the group of two or more peices, and the group of the remaining peices. This group signifies a group to that will be "joined back together", to simulate the cut cost.

The recursion:\\
\begin{align*}
c(i, j) = \min
\begin{cases}
    A[i] + A[j],        & \text{if } j - i = 1\\
    c(i, k) + c(k+1, j) & \text{otherwise}\\
\end{cases}
    : i < k < j - 1
\end{align*}

Using this, we then examine every possible way of placing the outermost groupings, which follows from above when $c(0, n)$. Doing so will calculate the solutions of all the subproblems, however some will have already been calculated and stored in slots $(i, j)$ of our table.

Our solution is trivially optimal as we are solving through an exhuastive search.

\textbf{Proof of optimality:}\\
text

\section*{Question 3}
r(i+1, j) if not equal
r(i+1, j+1) + r(i+1, j) if equal

\section*{Question 4}
solution of your children
or your value plus the solution of your grandchildren

\section*{Question 5}
if A[a] == S[j]:
    r(a+1, b, j+1)
if B[b] == S[j]:
    r(a, b+1, j+1)
add the matching string to a set, check for existance before recursing

\section*{Question 6}
extend towers by always picking the lightest turtle and then ordering by the sum of their Strength and weights

\end{document}
