\documentclass{article}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{chngcntr}
%\usepackage{tikz}

\lhead{Evan Kohilas - z5114986}
\rhead{COMP3821 - Assignment 4}
\pagestyle{fancy}
\title{A17S1N4}
\counterwithin*{equation}{section}
\usepackage{parskip}

%\begin{verbatim}
%code goes here
%\end{verbatim}

\begin{document}

\begin{center}
    \begin{LARGE}
        COMP3121\\
        Assignment 4\\
        A17S1N3\\
        \hrulefill\\
        Evangelos Kohilas\\
        z5114986\\
        \hrulefill
    \end{LARGE}

    \begin{large}
        By submitting this document you are confirming that all the answers are your work and are not take from any other sources unless clearly mentioned.
    \end{large}

\end{center}

\section*{Question 1}
To create the longest subsequence of elephants, we first sort the elephants in decreasing order of IQs$^{12}$.

Then, we find the longest increasing subsequence of weight from our collection of sorted elephants.

Let $S$ be our sorted collection, with $S[i]$ denoting the $i^{th}$ elephant in the sequence.\\
Let $W(i)$ be the given weight of elephant $i$.

Then, for each elephant $i$ in the collection, we let our subproblem be finding a subsequence of maximum length such that $W(i)$ is increasing and the subsequence ends with elephant $i$.

We do this process recursively, assuming we have solved all the subproblems for some $j < i$, and we look for all elephants $m$ such that $W(m) \leq W(i)$ and $S[m] \leq  S[i]$, picking elephant $m$ which produced the longest increasing subsequence ending with $m$, and extending it to our subproblem to obtain the longest increasing subsequence ending with elephant $i$

Our solution is optimal as truncating the solution $i$ will produce the optimal solution of the subproblem $m$.

$^1$ Sorting by the weight will also achieve the same result provided the method is inversed.\\
$^2$ If two elephants have the same value, we then sort those elephants by the respective inverse of the other value.

\pagebreak
\section*{Question 2}
Let $A$ be the sequence of wooden peices that will be cut from dividing the wooden stick respective to its marks, with $A[i]$ denoting the size of the $i^{th}$ peice in the sequence.\\
Let $n$ be the total number of respective peices.

Let the subproblems to be considered as $c(i, j)$ be the minimum of the group of two or more peices, and the group of the remaining peices. This group signifies a group to that will be "joined back together", to simulate the cutting cost.

The recursion:
\begin{align*}
c(i, j) = \min
\begin{cases}
    A[i] + A[j],        & \text{if } j - i = 1\\
    c(i, k) + c(k+1, j) & \text{otherwise}\\
\end{cases}
    : i < k < j - 1
\end{align*}

Using this, we then examine every possible way of placing the outermost groupings, which follows from above when $c(0, n)$. Doing so will calculate the solutions of all the subproblems, however some will have already been calculated and stored in slots $(i, j)$ of our table.

Since we are examining every possible grouping, our solution is trivially optimal.

\section*{Question 3}

Let $A$ be a sequence of Roman letters, with $A[i]$ denoting the $i^{th}$ letter of $A$.\\
Let $B$ be a sequence of Roman letters, with $B[i]$ denoting the $i^{th}$ letter of $B$.


Assuming our base cases are solved, we fill our table $T$, for all $0 \leq a < |A|$ and all $0 \leq b < |B|$ (row by row) as shown in the recursion:
\begin{align*}
s(a, b) =
\begin{cases}
    s(a, b+1),              & \text{if } A[a] \neq B[b]\\
    s(a, b+1) + s(a+1, b+1) & \text{if } A[a] = B[b]
\end{cases}
\end{align*}

Finally, the number of sequences found will then be stored in the bottom right of the table, $T[|A|-1][|B|-1]$.

Since we are iterating over every combination of characters, our solution is trivially optimal.

\section*{Question 4}
Let each supervisor be a node.
Let the supervisors' employees' be the node's children.
Let the fun rating of an employee be value.

We then let our subproblem be the maximum of either the total maximum of a node's children, or total of the node's value and the maximum of each children's children.

We do this process recursively, assuming we have solved all the subproblems for some $i$. By picking the maximal set of positioned nodes, we are always extending our original subproblem with the largest total value to obtain an increasing total value that must end at the current node.

Thus, our solution is optimal as truncating the solution $i$ will still produce the optimal solution of the subproblem $m$.

\section*{Question 5}
\begin{align*}
r(a, b, i) =
\begin{cases}
    r(a+1, b, i+1), & \text{if } A[a] = S[i]\\
    r(a, b+1, i+1), & \text{if } B[b] = S[i]\\
    True            & \text{if } a == length(A) and b == length(b) and i== length(i)

\end{cases}
\end{align*}
if A[a] == S[j]:
    r(a+1, b, j+1)
if B[b] == S[j]:
    r(a, b+1, j+1)
add the matching string to a set, check for existance before recursing

\section*{Question 6}
extend towers by always picking the lightest turtle and then ordering by the sum of their Strength and weights

\end{document}
